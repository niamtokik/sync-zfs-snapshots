#!/usr/bin/env python3
######################################################################
# sync-zfs-snapshots - 
# 
######################################################################

import sys
import argparse
import os
import time
import datetime
import subprocess
import io
import re
import argparse
import logging

logLevel = 0

def uri_parser(uri):
    """
    >>> uri = uri_parser("ssh://myuser@myserver:1234:/my/path")
    >>> uri.group('sourcepath') == '/my/path'
    True
    >>> uri.group('user') == 'myuser'
    True
    >>> uri.group('server') == 'myserver'
    True
    >>> uri.group('port') == '1234'
    True
    """
    return re.search (r'ssh://(?P<user>[^@]*)@(?P<server>[^:]*):((?P<port>[^:]*):)?(?P<sourcepath>.*)$', uri)

class ZFSFilesystem:
    def __init__(self, uri, sshIdentity = None):
        zfsRE = uri_parser(uri)
        if zfsRE:
            self.ssh = True
            self.sourcePath = zfsRE.group('sourcepath')
            self.user = zfsRE.group('user')
            self.server = zfsRE.group('server')
            self.port = zfsRE.group('port')
            self.sshIdentity = sshIdentity[0] if sshIdentity else None
        else:
            self.ssh = False
            self.sourcePath = uri
        logging.debug(vars(self))

    def getZPoolFilesystem (self):
        return self.sourcePath

    def getZFSCmdLine (self, args):
        cmdLine = []
        if self.ssh:
            cmdLine.append ('ssh')
            if self.port:
                cmdLine.extend (['-p', self.port])
            if self.sshIdentity:
                cmdLine.extend (['-i', self.sshIdentity])
            cmdLine.append (self.user + '@' + self.server)
        cmdLine.extend (args)
        logging.debug(cmdLine)
        return cmdLine

def zfs_get(target):
    """ generate a list containing zfs get command
    """
    ret = ['zfs', 'get', '-Hpd', '1', 'creation', target.getZPoolFilesystem()]
    logging.debug(ret)
    return ret

def zfs_send_incremental(source, predecessorSubvolume, sourceSubvolume):
    """ generate a list containing zfd incremental send command
    """
    ret = ['zfs', 'send', '-i', source.getZPoolFilesystem() + '@' + predecessorSubvolume, source.getZPoolFilesystem() + '@' + sourceSubvolume]
    logging.debug(ret)
    return ret

def zfs_send(source, predecessorSubvolume, sourceSubvolume):
    """ generate a list containing zfs send command
    """
    ret = ['zfs', 'send', source.getZPoolFilesystem() + '@' + sourceSubvolume]
    logging.debug(ret)
    return ret

def zfs_recv(target):
    """ generate a list containing zfs receive command
    """
    ret = ['zfs', 'receive', '-Fv', target.getZPoolFilesystem()]
    logging.debug(ret)
    return ret

def readSubvolumesByCreation (zfsProc):
    subvolumesByCreation = { }
    for line in zfsProc.stdout.readlines ():
        theLine = line.decode ().strip ()
        lineRE = re.search( r'.*@(.*)\tcreation\t([0-9]*)\t.*$', theLine)
        if lineRE:
            snapPath = lineRE.group(1)
            snapCreation = lineRE.group(2)
            subvolumesByCreation[snapCreation] = snapPath
        else:
            logging.warning("bad line: %s", theLine)
    return subvolumesByCreation

def invertMap (map):
    result={}
    for key in sorted (map):
        result[map[key]] = key
    return result

def printMap (map):
    for key in sorted (map):
        print (key, map[key])

def main(argv):
    global logLevel

    parser = argparse.ArgumentParser(description='Synchronise all snapshots in a ZFS filesystem to another zfs filesystem.  Useful for synchronising backups.')
    parser.add_argument ("--debug", dest='debug', nargs='?', const=1, type=int, help='Debug level of the application.  Uses debug 1 if flag is passed without a number.')
    parser.add_argument ("--sshIdentity", dest='sshIdentity', nargs=1, help='ssh identity key file to use when ssh-ing to destination servers')
    parser.add_argument ("source", help='Source ZFS filesystem.  Local filsystems are specified as zpool/filesystem.  Remote ones are specified as ssh://user@server[:port]:zpool/filesystem.')
    parser.add_argument ("destination", help='Destination ZFS filesystem.  Same format as source.')

    args = parser.parse_args()
    logging.debug("arguments: %s", str(args))

    if args.debug:
        logLevel = args.debug


    source = ZFSFilesystem(args.source, sshIdentity=args.sshIdentity)
    logging.debug("create dataset source object")
    
    destination = ZFSFilesystem(args.destination, sshIdentity = args.sshIdentity)
    logging.debug("create dataset destination object")
    
    sourceZfsProc = subprocess.Popen(source.getZFSCmdLine(zfs_get(source)), stdout=subprocess.PIPE)
    sourceSubvolumesByCreation = readSubvolumesByCreation(sourceZfsProc)
    sourceCreationBySubvolumes = invertMap(sourceSubvolumesByCreation)
    sourceCreatedSorted = sorted(sourceSubvolumesByCreation)

    destinationZfsProc = subprocess.Popen(destination.getZFSCmdLine(zfs_get(destination)), stdout=subprocess.PIPE)
    destinationSubvolumesByCreation = readSubvolumesByCreation (destinationZfsProc)
    destinationCreationBySubvolumes = invertMap(destinationSubvolumesByCreation)

    for volIndex, volKey in enumerate(sourceCreatedSorted):
        sourceSubvolume = sourceSubvolumesByCreation[volKey]

        if sourceSubvolume in destinationCreationBySubvolumes:
            logLevel > 0 and print("# Already present:", sourceSubvolume)
        else:
            if volIndex > 0:
                predecessorSubvolumeKey = sourceCreatedSorted[volIndex - 1]
                predecessorSubvolume = sourceSubvolumesByCreation[predecessorSubvolumeKey]
                logging.warning("Missing subvolume %s and predecessor %s", sourceSubvolume, predecessorSubvolume)
                sendCmd = source.getZFSCmdLine(zfs_send_incremental(source, predecessorSubvolume, sourceSubvolume))
            else:
                logging.warning("Missing initial subvolume %s", sourceSubvolume)
                sendCmd = source.getZFSCmdLine(zfs_send(source, sourceSubvolume))

            receiveCmd = destination.getZFSCmdLine(zfs_recv(destination))
            fullCmdLine = ' '.join (sendCmd) + ' | dd | ' + ' '.join (receiveCmd)

            logLevel > 0 and print (fullCmdLine)
            result = subprocess.call(fullCmdLine, shell = True)

            if result:
                logging.error("error running '%s'", fullCmdLine)
                sys.exit(1)
    
if __name__ == "__main__":
    main(sys.argv[1:])
    logging.basicConfig(level=logging.DEBUG)
    sys.exit(0)



